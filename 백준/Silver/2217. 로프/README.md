# [Silver IV] 로프 - 2217 

[문제 링크](https://www.acmicpc.net/problem/2217) 

### 성능 요약

메모리: 36264 KB, 시간: 104 ms

### 분류

수학, 그리디 알고리즘, 정렬

### 제출 일자

2026년 2월 3일 18:49:57

### 문제 설명

<p>N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.</p>

<p>하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.</p>

<p>각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.</p>

### 입력 

 <p>첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.</p>

### 출력 

 <p>첫째 줄에 답을 출력한다.</p>

---

## 🔧 Fail Log

### 아이디어
- 모든 로프를 사용하면 최대 하중이 `min(ropes) * N`일 것이라 가정했다.

### 그리디라고 판단한 근거
- 로프 `k`개를 선택했을 때 최대 하중은 `min(선택 로프) × k`로 결정된다.  
  즉, 로프의 최대 하중은 **가장 약한 로프** 에 의해 정해진다.
- 따라서 최적해는 “어떤 로프를 최소값으로 둘 것인가”만 결정하면 되고 그 로프보다 강한 로프들은 **포함해도 최소값을 떨어뜨리지 않으므로 무조건 포함하는 게 이득**이다.

### 오답
#### 오답 유형
- `WA` 발생  
- 잘못된 접근(전제 자체가 틀림)으로 인한 오답

#### 오답 원인
- 모든 로프를 사용하는 게 최적이 아니라는 사실을 간과했다.
- 로프 `k`개를 선택했을 때 최대 하중은 `선택 로프들 중 최소 무게 × k` 이다.
- 약한 로프를 포함하면 `min`이 너무 작아져 오히려 결과가 감소할 수 있다.

### 해결 방법
- 로프를 정렬한 뒤, 각 로프를 “그 시점의 최소 로프”로 가정하고 후보를 전부 비교한다.
  - `ropes.sort()`
  - `max(ropes[i] * (N - i))`

### 다른 사람의 풀이에서 배운 점
- **카운팅 배열(빈도 배열)** 접근
- 로프의 최대 무게 범위가 제한되어 있을 때(예: 1~10000), `cnt[w] = 무게 w인 로프 개수`로 저장한다.
- 큰 무게부터 내려오며 누적 개수 `s(= w 이상 로프 개수)`를 갱신한다.
- 각 `w`가 선택 집합의 최소 로프일 때의 후보값을 계산한다.
  - 후보 하중: `w * s`

```python
import sys
IN = sys.stdin.readline

n = int(IN())
cnt = [0] * 10001

for _ in range(n):
    cnt[int(IN())] += 1

best = 0
s = 0  # s = 현재 무게 이상 로프 개수(누적)
for w in range(10000, 0, -1):
    if cnt[w]:
        s += cnt[w]
        best = max(best, w * s)

print(best)
```
