# [Silver V] 폴리오미노 - 1343 

[문제 링크](https://www.acmicpc.net/problem/1343) 

### 성능 요약

메모리: 32412 KB, 시간: 28 ms

### 분류

구현, 그리디 알고리즘, 문자열

### 제출 일자

2026년 2월 2일 19:19:41

### 문제 설명

<p>민식이는 다음과 같은 폴리오미노 2개를 무한개만큼 가지고 있다. AAAA와 BB</p>

<p>이제 '.'와 'X'로 이루어진 보드판이 주어졌을 때, 민식이는 겹침없이 'X'를 모두 폴리오미노로 덮으려고 한다. 이때, '.'는 폴리오미노로 덮으면 안 된다.</p>

<p>폴리오미노로 모두 덮은 보드판을 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 보드판이 주어진다. 보드판의 크기는 최대 50이다.</p>

### 출력 

 <p>첫째 줄에 사전순으로 가장 앞서는 답을 출력한다. 만약 덮을 수 없으면 -1을 출력한다.</p>

---

## 🔧 Fail log 

### 아이디어
- 사전 순으로 가장 앞서는 답을 출력해야 하므로 `AAAA`를 우선적으로 채워야 한다.
- `AAAA(4칸)`, `BB(2칸)`만 사용하므로 `X`로 채워야 하는 연속 구간 길이는 **짝수**여야 한다.
- 초기 시도: `.` 기준으로 split하여 `X` 구간별 길이를 구한 뒤
  - 길이가 짝수면 `AAAA`(4의 몫) + `BB`(2의 나머지)로 구성한다.
  - 길이가 홀수면 즉시 `-1`을 반환한다.
- 문제점 발견 후 개선: split 기반 재조립 대신 문자열을 **왼쪽부터 한 글자씩 스캔**하며
  - `.` 는 그대로 출력에 추가
  - `X` 는 연속 구간 길이(`x_len`)를 구해 `AAAA/BB`로 치환한다.

### 알고리즘 판단 근거
- 각 `X` 연속 구간은 다른 구간과 독립적으로 타일링된다(`.`이 구간을 분리).
- 사전순 최소를 위해 가능한 한 앞에서부터 `AAAA`를 최대한 사용하고(`x_len // 4`),
  남은 2칸 단위만 `BB`로 채운다(`(x_len % 4) // 2`).
- 어떤 연속 구간이라도 길이가 홀수면 `AAAA/BB`로 덮을 수 없으므로 전체 답은 `-1`.

### 복잡도
- 시간: `O(n)`  
  - 문자열을 한 번 스캔하며, `j`가 전체를 통틀어 최대 `n`번만 증가하는 투 포인터 구조
- 공간: `O(n)`  
  - 결과 문자열(리스트)에 대한 공간.

### 오답
#### 오답 유형
- WA 발생  
  - 문제의 조건을 충분히 고려하지 않아 발생한 오답

#### 오답 원인
- 1차 시도: `split('.')` 사용으로 인해 연속된 `.` 사이에 `''`(빈 문자열)이 끼어들어
  **점의 개수를 정확히 보존하지 못하는 케이스**가 생겼다.
  - 결과적으로 원본의 `.` 배치/개수와 출력이 달랐다.
- 2차 시도: split 결과를 기반으로 `.` 개수를 따로 세어 복원하거나
  빈 문자열 처리 로직을 추가해야 했는데 구현이 번거롭고 실수 여지가 높았다.

### 해결 방법
- `split` 기반 접근을 폐기하고 문자열을 왼쪽부터 읽는 방식으로 변경했다.
  - `.` 를 만나면 그대로 `answer.append('.')`
  - `X` 를 만나면 `j`를 이동시켜 연속 구간 길이 `x_len` 계산
    - `x_len` 홀수면 즉시 `-1` 출력
    - 짝수면 `'AAAA' * (x_len // 4) + 'BB' * ((x_len % 4) // 2)` 를 추가
  - 처리한 `X` 구간은 `i = j`로 한 번에 건너뛰어 전체를 `O(n)`에 처리한다

### 다른 사람의 풀이에서 배운 점
- `replace`를 순서대로 적용하는 방식으로도 해결 가능했다.
- 핵심은 `XXXX → AAAA`를 먼저 치환한 뒤, 남은 `XX → BB`를 치환하는 것이다.
  - 큰 블록을 먼저 처리해야 사전순 최소(`AAAA` 우선)를 자연스럽게 만족한다.
- 치환 후에도 `X`가 남아 있으면 어떤 연속 구간이 홀수였다는 의미이므로 `-1` 처리한다.

```python
def solution(s):
    s = s.replace('XXXX','AAAA').replace('XX','BB')
    return -1 if 'X' in s else s

s = input().strip()
print(solution(s))
```
